/*
 *        (C) COPYRIGHT Daniel Wang Limited.
 *             ALL RIGHTS RESERVED
 *
 * File       : mariana_api.h
 * Authors    : wangliquan@cc-SYS-7048GR-TR
 * Create Time: 2023-08-02:08:34:05
 * Description:
 *
 */

#ifndef __MARIANA_API_H__
#define __MARIANA_API_H__

#include <string>
#include <vector>
#include <unordered_map>
#include <typemeta.h>

namespace mariana {

enum class DeviceType : int8_t { // DO NOT CHANGE THE NUMBERS OF BELLOW.
    UNINIT=0,
    CPU=0,
    CUDA=1,
    FPGA=2,
    // If you add other devices
    //  - Change the implementations of DeviceTypeName and isValidDeviceType
    //    in device_ype.cpp
    //  - Change the number below
    COMPILE_TIME_MAX_DEVICE_TYPES=3
};

struct Point2D {
    Point2D();
    Point2D(float _x, float _y);
    ~Point2D();
    float x;
    float y;
};

struct Rect {
    Rect();
    ~Rect();
    float area() const;
    float w() const;
    float h() const;
    Point2D cxy() const;
    Point2D tl;
    Point2D br;
};

struct NNResult {
    NNResult();
    ~NNResult();
    float score;
    int32_t cls_idx;
    std::string class_name;
    Rect bbox;
    std::vector<Point2D> points;
};

//Contains all results generated by inference for each image.
struct InferResult {
    InferResult();
    ~InferResult();
    std::vector<NNResult> collection;
};


/*
 * @member identification: per-frame identifier.
 * @member collection: The full results of this reasoning.
 */
struct MResult {
    MResult();
    ~MResult();
    std::string identification;
    std::vector<InferResult> collection;
};

/*
 * Pointer dst is pre-allocated memory by yourself, if pass dst=nullptr, this function will allocate 
 * memory internal and return it, if pass dst!=nullptr, it will not allocate memory, and dst as the 
 * retrun value. whether or not pass the dst, you should free the return value.

 * @member shape: The shape of pointer input .
 * @member input: The data pointer that allocation by external.
 * @member dtype: The type of data.
 * @member device: On which device the data was allocated.
 */
struct MTensor { // It hold external data pointer only, is not responsible for freeing memory.
    MTensor();
    ~MTensor();
    void* to_cpu(void* dst=nullptr) const;
    std::vector<int32_t> shape;
    void* input;
    TypeMeta dtype;
    DeviceType device;
};

/*
 * @member channel_id: Identification of channel.
 * @member identification: per-frame identifier.
 * @member itensors: Input data for inference.
 * @member info: If the image is pre-processed, the parameters of the pre-processing are needed for post-processing.
 * @member anything: Put anything you want to process.
 */
struct ExecContext {
    ExecContext();
    ~ExecContext();
    struct ExtraInfo {
        int pad_h;
        int pad_w;
        float scale;
    };
    std::string channel_id;
    std::string identification;
    std::unordered_map<std::string, MTensor> itensors;
    ExtraInfo info;
    void* anything;
};

/*
 * It can be used to synchronize reasoning.
 * When the model is strongly correlated with the device, use @build function to build the model.
 */
struct Runtime {
    static bool build(const char* prototxt);
    static Runtime create_from(const char* prototxt);
    void destory();
    MResult run_with(ExecContext& econtext);
    std::vector<std::string> input_names;
    std::vector<std::string> output_names;
private:
    void* handle_ = nullptr;
};

/*
 * @member num_thread: Number of threads of the algorithm.
 * @member max_ibuffer_size: Maximum length of the input queue.
 */
struct ScheduleConfig {
    ScheduleConfig();
    ~ScheduleConfig();
    int num_thread;
    int max_ibuffer_size;
};

/*
 * You can use @session for multiplexed asynchronous inference of algorithms.
 */
struct Session {
    Session();
    ~Session();
    void* add_section(const char* prototxt, const ScheduleConfig& config);
    void add_channel(const char* channel_id, void* do_not_change);
    void push_with(ExecContext& context, void* do_not_change);
    MResult pull(ExecContext& context, void* do_not_change);
    std::vector<std::string> get_onames_from(void* do_not_change);
    std::vector<std::string> get_inames_from(void* do_not_change);
private:
    void* handle_ = nullptr;
};

} // namespace mariana

#endif /* __MARIANA_API_H__ */

